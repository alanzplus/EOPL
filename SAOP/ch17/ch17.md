# Chapter 17 Using Continuations

## 17.5 Escaping From and Returning to Deep Recursions

### Break Point Utility
Based on the ideas of examples, create a `break` function for breakpoint like debugging.

`break` suspends the procedure execution and it allows view/change the value of expression.

```racket
(define escaper "undefined")
(let ([r (lambda (cont)
           (set! escaper
             (lambda (proc)
               (lambda args
                 (cont (lambda () (apply proc args))))))
           (lambda () writeln "escaper is defined"))])
  ((call/cc r)))

(define resume "undefined")
(define breakpoint "undefined")
(define view (lambda () breakpoint))
(define change (lambda (v) (set! breakpoint v)))
(define break
  (lambda (x)
    (let ([r (lambda (cont)
               (set! resume (lambda () (cont (view))))
               (set! breakpoint x)
               ((escaper (lambda () x))))])
      (call/cc r))))
```

Use `break` on function `flatten-number-list`

```racket
(define flatten-number-list
  (lambda (s)
    (cond
      [(null? s) '()]
      [(number? s) (list s)]
      [else
        (append
          (flatten-number-list (break (car s)))
          (flatten-number-list (cdr s)))])))
```

```
> (flatten-number-list '(1 2 3))
'(1)
> (view)
1
> (change '(1984 4894))
> (resume)
'(1984)
> (resume)
'(4891)
> (resume)
'(2)
> (resume)
'(3)
> (resume)
'(1984 4891 2 3)
```

## Exercise 
### 17.1
**Description**

> Rewrite cycle-proc using continutaions instead of recursion as presented in Program 14.11.

> Program 14.11

```racket
(define cycle-proc
  (lambda (th)
    (letrec ([loop (lambda ()
                     (th)
                     (loop))])
      (loop))))
```

**Solution**

```racket
(define cycle-proc
  (lambda (th)
    (let ([cc (call/cc (lambda (cont) cont))])
      (th)
      (cc cc))))
```

### 17.3
**Description**

> Determine what this expression represents:

[1]

```racket
(let ([receiver (lambda (continutation)
                  (call/cc continutation))])
  (call/cc receiver))
```

[2]

> What is (call/cc call/cc) ?

**Solution**

[1]

```
(call/cc receiver)

=>

(receiver (escaper (lambda (val) val)))

=>

(call/cc (escaper (lambda (val) val)))

=>

(
  (escaper (lambda (val) val))
  (escaper (lambda (val) val)))
```

[2]

```
(call/cc call/cc)

=>

(call/cc (escaper (lambda (val) val)))

=>

(
  (escaper (lambda (val) val))
  (escaper (lambda (val) val)))
```
